<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org/DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.kbstar.mapper.StockMapper">
    <!-- 기본 select 사용안함 -->
    <select id="select" parameterType="Integer" resultType="stock">
        SELECT * FROM stock WHERE product_id=#{product_id}
    </select>
    <!-- product_id로 조회시 변경등록일자가 있는 List<Stock> 반환 -->
    <select id="selectchangehistory" parameterType="Integer" resultType="stock">
        SELECT * FROM stock WHERE product_id=#{product_id}
    </select>
    <!-- 변경등록일자가 있는 List<Stock> 반환 -->
    <select id="selectall" parameterType="Integer" resultType="stock">
        SELECT * FROM stock
    </select>
    <!-- 상품 전체 최종 재고 현황 -->
    <select id="selectfinalstock" resultType="stock">
    -- product가 stock 보다 중심인 비즈니스 일 때 (현재 erd)
        select t.*
        from (select p.product_id, p.product_name, s.product_costprice, p.product_price, s.product_amount, s.product_expectedamount, s.stock_updateday, s.stock_no
                   , rank()over (partition by p.product_id order by s.stock_no desc) as stock_rank
              from product p left join stock s on p.product_id=s.product_id ) t
        where t.stock_rank=1
    -- stock이 product보다 중심인 비즈니스일 때
--         select t.*
--         from (select s.product_id, p.product_name, s.product_costprice, p.product_price, s.product_amount, s.product_expectedamount, s.stock_updateday, s.stock_no
--                    , rank()over (partition by s.product_id order by s.stock_no desc) as stock_rank
--               from stock s left join product p on s.product_id=p.product_id ) t
--         where t.stock_rank=1
    </select>
    <!-- 예상 재고 업데이트를 위한 product key 추출 -->
    <select id="selectproductid" resultType="Integer"> <!-- 나중에 db는 수정할 필요 있어 보임. erd시 잘 짜야함 -->
        select distinct product_id from product
    </select>
    <!-- 장바구니 갯수로 예상 재고 계산 업데이트 -->
    <update id="updateexpectedamount" parameterType="Integer">
        -- 개별 상품 테스트
        UPDATE Stock st
        SET st.product_expectedamount = st.product_amount - (
            SELECT cg.cart_quantity
            FROM (
            SELECT c.product_id, SUM(c.cart_quantity) AS cart_quantity
            FROM cart c
            WHERE c.product_id = #{product_id}
            GROUP BY c.product_id
            ) cg
            )
        WHERE (st.stock_no, st.product_id) IN (
            SELECT t.stock_no, t.product_id
            FROM (
            SELECT s.stock_no, s.product_id, RANK() OVER (PARTITION BY s.product_id ORDER BY s.stock_no DESC) AS stock_rank
            FROM stock s) t
            WHERE t.stock_rank = 1 AND t.product_id = #{product_id}
            )
    </update>
    <!-- update 겸용으로 쓸 예정 -->
    <insert id="insert" parameterType="stock">
        INSERT INTO Stock (product_costprice, product_amount, product_expectedamount, product_id, stock_updateday, stock_no)
        VALUES (#{product_costprice}, #{product_amount}, #{product_expectedamount}, #{product_id}, SYSDATE, stock_seq.NEXTVAL)
    </insert>
    <delete id="delete" parameterType="Integer">
        DELETE FROM stock WHERE product_id=#{product_id}
    </delete>
<!--    <select id="getlowstock" resultType="stock">-->
<!--        &#45;&#45; product가 stock 보다 중심인 비즈니스 일 때 (현재 erd)-->
<!--        select t.*-->
<!--        from (select p.product_id, p.product_name, s.product_costprice, p.product_price, s.product_amount, s.product_expectedamount, s.stock_updateday, s.stock_no-->
<!--                   , rank()over (partition by p.product_id order by s.stock_no desc) as stock_rank-->
<!--              from product p left join stock s on p.product_id=s.product_id ) t-->
<!--        where t.stock_rank=1-->
<!--    </select>-->
</mapper>